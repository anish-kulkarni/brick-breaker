speciate(){
    Species empty_species;
    //generate speciators randomely
    repeat for (i = 0 to past_gen.species.size()-1){
        int r = random(0,past_gen.species[i].size() - 1);
        curr_gen.speciator[i] = past_gen.offspring[past_gen.species[i].individual[r]];
        curr_gen.species.append(empty_species);
    }

    //speciate
    repeat (for i=0 to curr_gen.offspring.size() – 1){
        bool is_speciated=false;
        repeat for j=0 to curr_gen.species.size() – 1{
            if( distance(curr_gen.offspring[i] , curr_gen.speciator[j]) < threshold_distance ){
                curr_gen.species[j].individual.append(i);
                is_speciated = true;
            }
        }
        //create new species if required
        if(!is_speciated){
            curr_gen.speciator.append(curr_gen.offspring[i]);
            curr_gen.species.append(empty_species);
            curr_gen.species[curr_gen.species.size()-1].individual.append(i);
        }
    }
}

double distance(Organism A, Organism B){
    int disjoint_genes=0,excess_genes=0,avg_weight_dif=0,
        c1=1,c2=1,c3=0.4;
    //assumption:genome of an individual lists the genes in increasing order of inovation number
    int A_genomelength, A_min_inovation_num, A_max_inovation_num,
        B_genomelength, B_min_inovation_num, B_max_inovation_num;
    A_genomelength = A.genome.connection_genes.size();
    B_genomelength = B.genome.connection_genes.size();
    A_min_inovation_num = A.genome.conection_genes[0].inovation_num;
    B_min_inovation_num = B.genome.conection_genes[0].inovation_num;
    A_max_inovation_num = A.genome.conection_genes[A_genomelength-1].inovation_num;
    B_max_inovation_num = B.genome.conection_genes[B_genomelength-1].inovation_num;
    int i=0,j=0;
    //identify initial few genes of A which are out range of the inovation number of B and vice versa.
    //These will be counted a disjoint genes
    while( A.genome.conection_genes[i].inovation_num < B_min_inovation_num ){
        disjoint_genes++;
        i++;
    }
    while( B.genome.conection_genes[j].inovation_num < A_min_inovation_num ){
        disjoint_genes++;
        j++;
    }
    //now count the excess genes and avg weight dif between genes with identical inovation number
    while( i<A_genomelength && j<B_genomelength){
        if(A.genome.conection_genes[i].inovation_num < B.genome.connection_gene[j].inovation_num){
            excess_genes++;
            i++;
        }
        if(A.genome.conection_genes[i].inovation_num > B.genome.connection_gene[j].inovation_num){
            excess_genes++;
            j++;
        }
        if(A.genome.conection_genes[i].inovation_num == B.genome.connection_gene[j].inovation_num){
            avg_weight_dif += abs(A.genome.conection_genes[i].weight - B.genome.conection_genes[i].weight);
            i++;j++;
        }
    }
    //last few genes of A which are out of range of the inovation number of B (or vice versa) will be counted as disjoint genes.
    //This is equivalent to adding (A_genomelength-i)+(B_genomelength) to disjoint_genes
    if(i < A_genomelength){
        disjoint_genes += A_genomelength - i;
    else
        disjoint_genes += B_genomelength - j;
    }
    double maxlength = max(A_genomelength,B_genomelength)
    double distance = c1*excess_genes/maxlength + c2*disjoint_genes/maxlegth + c3*avg_weight_dif;
    return distance;
}
